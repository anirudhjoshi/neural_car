<!DOCTYPE HTML>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			body{
				margin: 0;
			}
			canvas {
				background: black;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<script>
			var canvas = document.getElementById("canvas");
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			var ctx = canvas.getContext("2d");
			var ball = {
				"x" : 100,
				"y" : 100,
				"radius" : 10,
				"outerR" : 30,
				"vx" : 0,
				"vy" : 5,
				"ax" : 0,
				"ay" : 0,
				"dx" : 0,
				"dy" : 1,
				"head" : 0
			};
			var rectangle = {
				"x" : 0,
				"y" : 0,
				"width" : 200,
				"height" : 200
			};
			function clear() {
				// Store the current transformation matrix
				ctx.save();
				// Use the identity matrix while clearing the canvas
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				// Restore the transform
				ctx.restore();
			}
			var keyMap = {
				"left": { "code" : 65, "on": false },
				"up": { "code" : 87, "on": false },
				"right": { "code" : 68, "on": false },
				"down": { "code" : 83, "on": false }
			};
			window.addEventListener("keydown", function (e) {
				for (var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = true;
						break;
					}
				}   
			}, false);

			window.addEventListener("keyup", function(e) {
				for(var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = false;
						break;
					}
				}
			}, false);

			function updateBall(){
				if ( !ball.dx ) {
					ball.vx += 1;
				}else{
					ball.vx -= 1;
				}
				if ( !ball.dy){
					ball.vy += 1;
				}else{
					ball.vy -= 1;
				}
				if (ball.vx > 5){
					ball.dx = 1;
				}else if(ball.vx < -5){
					ball.dx = 0;
				}
				if (ball.vy>5){
					ball.dy=1;
				}else if(ball.vy < -5){
					ball.dy=0;
				}
				ball.vx += ball.ax;
				ball.vy += ball.ay;
				ball.x += ball.vx;
				ball.y += ball.vy;
				if(ball.vx==0){
					if(ball.vy>0)
						head = Math.PI/2;
					else
						head = -1 * Math.PI/2;
				}else{
					head = Math.atan(ball.vy/ball.vx);
				}
			}
			function fetchInfo(){
				var distance = {
					"head" : 0,
					"sideLM" : 0,
					"sideRM" : 0,
					"sideL" : 0,
					"sideR" : 0
				};
				var centreX = ball.x;
				var centreY = ball.y;
				var radi = ball.radius;
				var outer = ball.outerR;
				var edgeWest = rectangle.x;
				var edgeEast = rectangle.x + rectangle.width;
				var edgeNorth = rectangle.y;
				var edgeSouth = rectangle.y + rectangle.height;

				var upORdown;
				if(ball.vy>0)
					upORdown = 1;
				else
					upORdown = -1;
				var headx = outer*Math.sin(ball.head)*upORdown;
				var heady = outer*Math.cos(ball.head)*upORdown;
				var sideLMx = outer*Math.sin(ball.head+Math.PI/4)*upORdown;
				var sideLMy = outer*Math.cos(ball.head+Math.PI/4)*upORdown;
				var sideRMx = outer*Math.sin(ball.head-Math.PI/4)*upORdown;
				var sideRMy = outer*Math.cos(ball.head-Math.PI/4)*upORdown;
				var sideLx = outer*Math.sin(ball.head+Math.PI/2)*upORdown;
				var sideLy = outer*Math.cos(ball.head+Math.PI/2)*upORdown;
				var sideRx = outer*Math.sin(ball.head-Math.PI/2)*upORdown;
				var sideRy = outer*Math.cos(ball.head-Math.PI/2)*upORdown;

				var x = [ headx, sideLMx, sideRMx, sideLx, sideRx ];
				var y = [ heady, sideLMy, sideRMy, sideLy, sideRy ];
				var results = [ distance.head, distance.sideLM, distance.RM, distance.sideL, distance.sideR ];
				var testx;
				var testy;
				var sum;
				for(var i in x.length){
					sum = 0;
					testx = x[i] + centreX;
					testy = y[i] + centreY;
					if(testx > edgeEast)
						sum += pow(testx-edgeEast, 2);
					else if(testx < edgeWest)
						sum += pow(edgeWest-testx, 2);
					if(testy > edgeSouth)
						sum += pow(testy-edgeSouth, 2);
					else if(testy < edgeNorth)
						sum += pow(edgeNorth-testy, 2);
					results[i] = sqrt(sum);
				}
				console.log(distance);
			}
			function update(){
				updateBall();
				fetchInfo();
			}
			function drawBall() {
				//draw a circle
				ctx.beginPath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.fillStyle = "#ff0000";
				ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2, true); 
				ctx.closePath();
				ctx.stroke();
				ctx.fill();
				ctx.beginPath();
				ctx.arc(ball.x, ball.y, ball.outerR, 0, Math.PI*2, true);
				ctx.closePath();
				ctx.stroke();
			}

			function drawRectangle() {
				//draw a circle
				ctx.strokeStyle = "grey";
				ctx.fillStyle = "grey";
				ctx.fillRect( rectangle.x, rectangle.y, rectangle.width, rectangle.height )
			}
			function render(){
				drawRectangle();
				drawBall();
			}
			function loop(){
				clear();
				update();
				render();
			}
			setInterval( loop, 1000/60 );

			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function(){
				return  window.requestAnimationFrame       || 
				window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function( callback ){
					window.setTimeout(callback, 1000 / 60);
				};
			})();

			// usage: 
			// instead of setInterval(render, 16) ....
			(function(){
				requestAnimFrame(loop());
			  // clear();
			  // update();
			  // render();
			})();
			// place the rAF *before* the render() to assure as close to 
			// 60fps with the setTimeout fallback.

		</script>
	</body>
</html>