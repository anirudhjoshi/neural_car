<!DOCTYPE HTML>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			body{
				margin: 0;
			}
			canvas {
				background: black;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>


		<script type="text/javascript" src="./brain-0.6.0.js"></script>		
		<script>

			var nets = 15;
			var net_array = new Array(nets);


			for ( var i = 0; i < nets; i ++ ) {

				net_array[i] = new brain.NeuralNetwork({
   						hiddenLayers: [8],
   						learningRate: 0.6
					});

				net_array[i].train([{input: [10*Math.random(), 10*Math.random(), 10*Math.random(), 10*Math.random(), 10*Math.random()], output: [1*Math.random(),1*Math.random()]}])

			}

			for ( var i = 0; i < nets; i ++ ) {

				// console.log( net_array[i].run( [0, 0, 0, 0, 0] ) );

			}

			var canvas = document.getElementById("canvas");

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

			var ctx = canvas.getContext("2d");
			var ball = {
				"x" : 200,
				"y" : 200,
				"speed" : 5,
				"radius" : 10,
				"outerR" : 30,
				"theta" : 0,
				"vx" : 0,
				"vy" : 0,
				"ax" : 0,
				"ay" : 0,
				"dx" : 0,
				"dy" : 1
			}
			var rectangle = {
				"x" : 100,
				"y" : 100,
				"width" : canvas.width - 400,
				"height" : 200

			}
			function clear() {
				// Store the current transformation matrix
				ctx.save();
				// Use the identity matrix while clearing the canvas
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				// Restore the transform
				ctx.restore();
			}
			var keyMap = {
				"left": { "code" : 65, "on": false },
				"up": { "code" : 87, "on": false },
				"right": { "code" : 68, "on": false },
				"down": { "code" : 83, "on": false },
			}                     
			window.addEventListener("keydown", function(e) {
				for(var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = true;
						break;
					}
				}   
			}, false);

			window.addEventListener("keyup", function(e) {
				for(var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = false;
						break;
					}
				}
			}, false);

			function turnLeft(){

				ball.theta += 0.01;

				ball.vx = ball.speed * Math.sin( ball.theta );
				ball.vy = ball.speed * Math.cos( ball.theta );

			}

			function turnRight(){

				ball.theta -= 0.01;

				ball.vx = ball.speed * Math.sin( ball.theta );
				ball.vy = ball.speed * Math.cos( ball.theta );

			}			

			var counter = 0;

			function Point( x, y ){

				this.x = x;
				this.y = y;

			}

			function drawLine( point1, point2 ) {

			    ctx.beginPath();

			    ctx.strokeStyle = "white";
			    ctx.fillStyle = "white";
			    ctx.lineWidth = 0.5;

			    ctx.moveTo( point1.x, point1.y);
			    ctx.lineTo( point2.x, point2.y);				

			    ctx.closePath();
			    ctx.stroke();


			}

			var first_point = new Point( 10, 10);
			var next_point = new Point( 100, 100);

			function updateBall(){

				// if ( counter == nets )
				// 	counter = 0

				// var values = net_array[counter].run( [ 10*Math.random(), 10*Math.random(), 10*Math.random(), 10*Math.random(), 10*Math.random() ] )

				// if ( values[0] > 0.6 ){
				// 	console.log(values)
				// 	turnLeft()
				// 	}
				// else {
				// 	turnRight()
				// 	}
				// console.log( values )
				// console.log( values );
				first_point.x = ball.x;
				first_point.y = ball.y;

				turnLeft();
				// turnRight();
				// console.log( ball.vx, ball.vy );
				// if ( !ball.dx ) {
				// 	ball.vx += 1;
				// }else{
				// 	ball.vx -= 1;
				// }
				// if ( !ball.dy){
				// 	ball.vy += 1;
				// }else{
				// 	ball.vy -= 1;
				// }
				// if (ball.vx > 5){
				// 	ball.dx = 1;
				// }else if(ball.vx < -5){
				// 	ball.dx = 0;
				// }
				// if (ball.vy>5){
				// 	ball.dy=1;
				// }else if(ball.vy < -5){
				// 	ball.dy=0;
				// }
				ball.vx += ball.ax / 10;
				ball.vy += ball.ay / 10;
				ball.x += ball.vx / 10;
				ball.y += ball.vy / 10;

			}
			function update(){
				updateBall();

			}
			function drawBall() {
				//draw a circle
				ctx.beginPath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.fillStyle = "#ff0000";
				ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2, true); 
				ctx.closePath();
				ctx.stroke();
				ctx.fill();
				ctx.beginPath();
				ctx.arc(ball.x, ball.y, ball.outerR, 0, Math.PI*2, true);
				ctx.closePath();
				ctx.stroke();
			}

			function drawRectangle() {
				//draw a circle
				ctx.strokeStyle = "grey";
				ctx.fillStyle = "grey";
				ctx.fillRect( rectangle.x, rectangle.y, rectangle.width, rectangle.height )
			}
			function render(){
				drawRectangle();
				drawBall();
				drawLine( first_point, next_point );
			}
			function loop(){
				clear();
				update();
				render();

			}
			setInterval( loop, 1000/60 );

			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function(){
				return  window.requestAnimationFrame       || 
				window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function( callback ){
					window.setTimeout(callback, 1000 / 60);
				};
			})();

			// usage: 
			// instead of setInterval(render, 16) ....
			(function(){
				// requestAnimFrame(loop());
			  // clear();
			  // update();
			  // render();
			})();
			// place the rAF *before* the render() to assure as close to 
			// 60fps with the setTimeout fallback.

		</script>
	</body>
</html>