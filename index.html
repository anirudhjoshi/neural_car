<!DOCTYPE HTML>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			body{
				margin: 0;
			}
			canvas {
				background: black;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<button onClick="running = !running;">Switch</button>


		<script type="text/javascript" src="./brain-0.6.0.js"></script>		
		<script>

			var nets = 15;
			var net_array = new Array(nets);


			for ( var i = 0; i < nets; i ++ ) {

				net_array[i] = new brain.NeuralNetwork({
   						hiddenLayers: [8],
   						learningRate: 0.6
					});

				net_array[i].train([{input: [100*Math.random(), 100*Math.random(), 100*Math.random(), 100*Math.random(), 100*Math.random()], output: [1*Math.random(),1*Math.random()]}])

			}

			for ( var i = 0; i < nets; i ++ ) {

				// console.log( net_array[i].run( [0, 0, 0, 0, 0] ) );

			}

			var canvas = document.getElementById("canvas");

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

			var ctx = canvas.getContext("2d");
			var ball = {
				"x" : 150,
				"y" : 150,
				"speed" : 5,
				"radius" : 10,
				"outerR" : 30,
				"theta" : 0,
				"vx" : 0,
				"vy" : 0,
				"ax" : 0,
				"ay" : 0,
				"dx" : 0,
				"dy" : 1
			}
			var rectangle = {
				"x" : 100,
				"y" : 100,
				"width" : canvas.width - 400,
				"height" : 140

			}
			function clear() {
				// Store the current transformation matrix
				ctx.save();
				// Use the identity matrix while clearing the canvas
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				// Restore the transform
				ctx.restore();
			}
			var keyMap = {
				"left": { "code" : 65, "on": false },
				"up": { "code" : 87, "on": false },
				"right": { "code" : 68, "on": false },
				"down": { "code" : 83, "on": false },
			}                     
			window.addEventListener("keydown", function(e) {
				for(var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = true;
						break;
					}
				}   
			}, false);

			window.addEventListener("keyup", function(e) {
				for(var i in keyMap) {
					if( e.keyCode === keyMap[i].code ) {
						keyMap[i].on = false;
						break;
					}
				}
			}, false);

			function turnLeft(){

				ball.theta += 0.01;

				ball.vx = ball.speed * Math.sin( ball.theta );
				ball.vy = ball.speed * Math.cos( ball.theta );

			}

			function turnRight(){

				ball.theta -= 0.01;

				ball.vx = ball.speed * Math.sin( ball.theta );
				ball.vy = ball.speed * Math.cos( ball.theta );

			}			

			var counter = 0;

			function Point( x, y ){

				this.x = x;
				this.y = y;

			}

			function Line( point1, point2 ){

				this.point1 = point1;
				this.point2 = point2;

			}

			function lineIntersection( line1, line2 ) {

				var ip = new Point();

				var p1 = line1.point1;
				var p2 = line1.point2;
				var p3 = line2.point1;
				var p4 = line2.point2;

			    var nx, ny, dn;
			    var x4_x3 = p4.x - p3.x;
			    var pre2 = p4.y - p3.y;
			    var pre3 = p2.x - p1.x;
			    var pre4 = p2.y - p1.y;
			    var pre5 = p1.y - p3.y;
			    var pre6 = p1.x - p3.x;

			    nx = x4_x3 * pre5 - pre2 * pre6;
			    ny = pre3 * pre5 - pre4 * pre6;
			    dn = pre2 * pre3 - x4_x3 * pre4;
			    nx /= dn;
			    ny /= dn;
			    // has intersection
			    if (nx>= 0 && nx <= 1 && ny>= 0 && ny <= 1) {

			        ny = p1.y + nx * pre4;
			        nx = p1.x + nx * pre3;
			        ip.x = nx;
			        ip.y = ny;

			    } else {

			        // no intersection
		        	ip = false;

			    }

			    return ip

			}

			function drawLine( point1, point2 ) {

			    ctx.beginPath();

			    ctx.strokeStyle = "white";
			    ctx.fillStyle = "white";
			    ctx.lineWidth = 0.5;

			    ctx.moveTo( point1.x, point1.y);
			    ctx.lineTo( point2.x, point2.y);				

			    ctx.closePath();
			    ctx.stroke();


			}

			var line_length = 100;
			var first_point = new Point( 10, 10);
			var next_point = new Point( 100, 100);

			var index = 0;
			var counter = 0;

			function updateBall(){

				// if ( counter == nets )
				// 	counter = 0
				counter++;

				if (counter > 250 )
					counter = 0
					if ( index < 14)
						index++;
					else
						index = 0;


				var values = net_array[index].run( vector );
				console.log(values)
				// console.log(values)

				if ( values[0] > values[1] ){

					turnLeft()

					}
				else {

					turnRight()

					}
				// console.log( values )
				// console.log( values );


				turnLeft();
				// turnRight();
				// console.log( ball.vx, ball.vy );
				// if ( !ball.dx ) {
				// 	ball.vx += 1;
				// }else{
				// 	ball.vx -= 1;
				// }
				// if ( !ball.dy){
				// 	ball.vy += 1;
				// }else{
				// 	ball.vy -= 1;
				// }
				// if (ball.vx > 5){
				// 	ball.dx = 1;
				// }else if(ball.vx < -5){
				// 	ball.dx = 0;
				// }
				// if (ball.vy>5){
				// 	ball.dy=1;
				// }else if(ball.vy < -5){
				// 	ball.dy=0;
				// }
				ball.vx += ball.ax / 10;
				ball.vy += ball.ay / 10;
				ball.x += ball.vx / 10;
				ball.y += ball.vy / 10;

			}
			function update(){
				updateBall();

			}
			function drawBall() {
				//draw a circle
				ctx.beginPath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.fillStyle = "#ff0000";
				ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2, true); 
				ctx.closePath();
				ctx.stroke();
				ctx.fill();
				ctx.beginPath();
				ctx.arc(ball.x, ball.y, ball.outerR, 0, Math.PI*2, true);
				ctx.closePath();
				ctx.stroke();
			}



			function drawFeeler( point ) {
				//draw a circle
				ctx.beginPath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.fillStyle = "#ff0000";
				ctx.arc(point.x, point.y, 1, 0, Math.PI*2, true); 
				ctx.closePath();
				ctx.fill();
				ctx.stroke();

			}			

			function drawRectangle() {

				//draw a circle
				ctx.strokeStyle = "grey";
				ctx.fillStyle = "grey";
				ctx.fillRect( rectangle.x, rectangle.y, rectangle.width, rectangle.height )

			}

			var wall_left_up = new Point( rectangle.x, rectangle.y );
			var wall_right_up = new Point( rectangle.x + rectangle.width, rectangle.y );
			var wall_line_up = new Line( wall_left_up, wall_right_up);	

			var wall_left_down = new Point( rectangle.x, rectangle.y + rectangle.height );
			var wall_right_down = new Point( rectangle.x + rectangle.width, rectangle.y + rectangle.height );
			var wall_line_down = new Line( wall_left_down, wall_right_down);	

			var vector = new Array(5);

			var lines = [ wall_line_up, wall_line_down ];

			function render() {

				drawRectangle();
				drawBall();

				first_point.x = ball.x;
				first_point.y = ball.y;


				for ( var i = 0; i < 5; i ++ ) {

					next_point.x = line_length*Math.sin( ball.theta - Math.PI / 2 + i * Math.PI / 4 ) + ball.x;
					next_point.y = line_length*Math.cos( ball.theta - Math.PI / 2 + i * Math.PI / 4 ) + ball.y;						
					drawLine( first_point, next_point );

					var segment = new Line( first_point, next_point );

					for ( var j = 0; j < 2; j++ ){

						var ip = lineIntersection( segment, lines[j] );

						if ( ip ){

							drawFeeler( ip );

							vector[i] = Math.sqrt( Math.pow( ip.x - first_point.x, 2 ) + Math.pow(ip.y - first_point.y, 2) );


						} else {

							vector[i] = line_length;

						}

					}

				}

				// console.log( vector );



					// console.log( ip );
 // segment, wall_line
				// console.log( lineIntersection( segment, wall_line ) );

				

			}

			var running = true;

			function loop(){

				clear();
				update();
				render();

				if ( running )
					setTimeout( loop, 1000/60 );

			}

			loop();


			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function(){
				return  window.requestAnimationFrame       || 
				window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function( callback ){
					window.setTimeout(callback, 1000 / 60);
				};
			})();

			// usage: 
			// instead of setInterval(render, 16) ....
			(function(){
				// requestAnimFrame(loop());
			  // clear();
			  // update();
			  // render();
			})();
			// place the rAF *before* the render() to assure as close to 
			// 60fps with the setTimeout fallback.

		</script>
	</body>
</html>